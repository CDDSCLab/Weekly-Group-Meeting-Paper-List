# YYYY.MM.DD 分享纪要

- 分享人：龚凯
- 记录人：龚凯
- 关键词：**NVM、数据库索引**
- 分享PPT: [2022-05-27-NVM与数据库索引.pptx](./slides/2022-05-27-NVM与数据库索引.pptx) 

## 分享内容

### 问题描述

过去几十年中，传统计算机系统结构使用易失性内存与非易失性存储的结构，DRAM经由块设备接口或者文件系统访问硬盘或 SSD，造成很大的交互开销。此外扩展DRAM的容量面临需要更小粒度 单元（ cells 的瓶颈 ，因此DRAM并不适合构建大容量的内存系统。正在涌现的非易失性存储技术，比如 PCM[ STTRAM[25]，忆阻器，兼具高存储容量、非易失性、低时延、和字节可寻址的特性，因此可以在未来的存储系统中替代或补充 DRAM。 NVM的主要特性是数据直接持久化，读写时延不对称 通过内存总线直接访问 NVM的主存只有少于毫秒的时延。

使用NVM 作为整个系统的主存为设计持久性内存索引结构带来了机遇和挑战。新的非易失性存储介质 NVM 具有逼近 DRAM 的性能和细粒度读写 。 NVM 不 适用于现有 数据库管理系统 结构 的几个原因 是 ：面向磁盘的 DBMS 通过 块设备获得持久性存 储，同时具有较慢的随机 访问性能。 通常 这类 数据库 在内存增加缓存将顺序读写 性能 最大化 面向内存的 数据库 包含 克服 DRAM 易失性的模块，这类模块 对于 NVM 来说 则没有价值。 在两种结构中，保证数据库的修改持久化是系统设计主要需要考虑 的 ，包括 1 ）依据 存储设备处理随机写的速度考虑每层存储设备的数据布局 ，和 2 ）将存储在 内存中 元组（ tuple上的事务 存到 下层存储介质 。各类 基于 NVM 的 研究考虑的问题还包括 NVM 的读写不对称性，一致性，并行性，耐受性等。

NVM 作为持久性内存的最小传输单位为一个 cache line size64 byte 而具有失败原子性的写操作粒度为内存总线的宽度8byte 。内存控制器和 C PU通过对操作重排序最大化内存带宽，因此篡改了 NVM 的写顺序，造成 不一致。 例如我们插入一项数据到哈希表时的两个步骤，首先将新的数据写到哈希表，然后通过指针链接新的数据和哈希表。如果操作 2 发生在操作 1 之前则会发生内存泄露和野指针的情况 。对大于8 byte 的更新，则需要其他方式保证一致性，例如日志， shadowing ，和copy on write 。应用对于写操作的时机和 cacheline刷回主存的顺序管理能力有限需要使用 X86 处理器提供的 {Mfence CLflush Mfence} 保证操作的有序性进而保证数据的一致性。 另外 随着 C++ 的更新 C++11 中提出了一种新的指令 {happens before }}[ 。该指令能够决定写操作到达 cacheline 的顺序，而到 同一个 cacheline 的写操作，到达cacheline 的顺序即持久化到 NVM 的顺序。

### 解决思路

#### 方向一：NVM+B tree

**基本思路：部分持久化、减少对cacheline的写，叶子节点按照固定大小组织，和NVM的写大小对齐**

1. [LB+-Trees: Optimizing Persistent Index Performance on 3DXPoint Memory](http://www.vldb.org/pvldb/vol13/p1078-liu.pdf)

   键值对无序存放，通过bitmap和fingerprint信息来加快查找

   尽量写第一个cacheline，严格按照对齐后，第一个cacheline写满后迁移到后面的cacheline

#### 方向二：NVM+radix tree

**基本思路:高度压缩，原子更新**

1. [WORT: Write Optimal Radix Tree for Persistent Memory Storage Systems ](https://www.usenix.org/conference/fast17/technical-sessions/presentation/lee-se-kwon)

   前面讲到的B+tree变体通过一些方法不让对key进行比较来减少对nvm的读写，而radix tree是天生不需要进行key的比较的数据结构，并且它是一种确定性的数据结构，查找不需要比较key,这会提高cache命中率,不存储key,所以插入删除不需要调整树。文章认为这种结构更适合NVM

#### 方向三：NVM+hash

**基本思路:减少resize的开销，负载均衡**

1. [Level Hashing: A High-performance and Flexible-resizing Persistent Hashing Index Structure ](https://dl.acm.org/doi/10.1145/3322096)

   每个地址多个槽位，让一个桶可以存放多个键值对，类似布谷鸟哈希，设计两个hash函数，设计两层结构来进行resize的切换，最后的优化结果是每次插入最多附加一次移动的插入。

#### 方向三：NVM+skiplist

**基本思路:部分持久化**

1. [Design and implementation of skiplist-based key-value store on nonvolatile memory](https://link.springer.com/article/10.1007/s10586-019-02925-1)

   只有数据需要持久化再NVM上，上层可以基于数据进行重建，其对跳表结构也进行了相应优化，在内存中的跳表高度是随机的，这种是不确定性设计，这种不适合上下文搜索（搜索的数据和插入的顺序关联，例如查找最近插入的数据，某数据查询过多），因此设置相关阈值，如果查询次数过多则增加节点高度，同时在跳表中设置多个头指针，这样可以缩小查找范围
